<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChainCLI: ChainCLI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ChainCLILogoChainsOnlyTransparent.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ChainCLI
   </div>
   <div id="projectbrief">A modern C++20 command-line interface library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ChainCLI </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_2mainpage"></a> <b>ChainCLI</b> is a modern C++20 command-line interface library designed to make building CLI applications simple, intuitive, and maintainable. With its fluent API and method chaining approach, ChainCLI handles all the complex command-line parsing, help generation, and logging infrastructure so you can focus on implementing your application's core functionality.</p>
<h2><a class="anchor" id="autotoc_md0"></a>
Key Features</h2>
<ul>
<li><b>Fluent API</b>: Build your CLI with intuitive method chaining</li>
<li><b>Automatic Documentation</b>: Generate comprehensive help text automatically</li>
<li><b>Type-Safe Arguments</b>: Strongly typed argument parsing with custom type support</li>
<li><b>Command Hierarchies</b>: Support for nested subcommands and complex CLI structures</li>
<li><b>Extensible</b>: Easy to extend with custom types, formatters, and handlers</li>
</ul>
<h2><a class="anchor" id="autotoc_md1"></a>
Table of Contents</h2>
<ul>
<li>Quick Start</li>
<li>Commands</li>
<li>Arguments</li>
<li>Argument Groups</li>
<li>Cli Context</li>
<li>Command Docstrings</li>
<li>CliApp Configuration</li>
<li>Logging</li>
<li>Docformatters</li>
<li>Custom Types</li>
</ul>
<h2><a class="anchor" id="autotoc_md2"></a>
Quick Start</h2>
<p>The idea behind this library was to provide a very verbose and easy to understand way to create CLI-Applications, where everything that has to do with the command line interaction is done for you (create help documentation/route commands/logging), so you only have to write the actual logic of your application (e.g the interesting part). To achieve this it heavily relies on the name giving method chaining. To use it simply include the single header file <code>chain_cli.hpp</code> in your project.</p>
<p>In general, the procedure is as follows (see the demos for more specific examples):</p>
<h4><a class="anchor" id="autotoc_md3"></a>
1) Create a new CliApp instance from a CliConfiguration that carries your application-specific settings</h4>
<div class="fragment"><div class="line"><span class="keyword">auto</span> config = <a class="code hl_struct" href="structcli_1_1_cli_config.html">cli::CliConfig</a>();</div>
<div class="line">config.title = <span class="stringliteral">&quot;Calculator Demo&quot;</span>;</div>
<div class="line">config.executableName = <span class="stringliteral">&quot;calculator_demo&quot;</span>;</div>
<div class="line">config.description = <span class="stringliteral">&quot;Calculator Demo to test the CLI Library&quot;</span>;</div>
<div class="line">config.version = <span class="stringliteral">&quot;1.0.0&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> cliApp = <a class="code hl_class" href="classcli_1_1_cli_app.html">cli::CliApp</a>(std::move(config));</div>
<div class="ttc" id="aclasscli_1_1_cli_app_html"><div class="ttname"><a href="classcli_1_1_cli_app.html">cli::CliApp</a></div><div class="ttdoc">Main class representing a command-line application.</div><div class="ttdef"><b>Definition</b> cli_app.h:44</div></div>
<div class="ttc" id="astructcli_1_1_cli_config_html"><div class="ttname"><a href="structcli_1_1_cli_config.html">cli::CliConfig</a></div><div class="ttdoc">Holds the configuration for the CLI application.</div><div class="ttdef"><b>Definition</b> cli_config.h:24</div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md4"></a>
2) Customize behaviour by adding your own/default handlers/formatters to the logger or docwriter</h4>
<div class="fragment"><div class="line"><span class="keyword">auto</span> &amp;logger = cliApp.Logger();</div>
<div class="line">logger.setLevel(LogLevel::TRACE); <span class="comment">//the default would be info</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Attach a file handler (logs everything to one file) - by default only a console handler is added</span></div>
<div class="line">logger.addHandler(std::make_unique&lt;FileHandler&gt;(<span class="stringliteral">&quot;app.log&quot;</span>, std::make_shared&lt;BasicFormatter&gt;(), LogLevel::TRACE));</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md5"></a>
3) Define your commands with the desired arguments and add them to the application</h4>
<div class="fragment"><div class="line"><span class="keyword">auto</span> addCommand = std::move(<a class="code hl_class" href="classcli_1_1commands_1_1_command.html">cli::commands::Command</a>(<span class="stringliteral">&quot;add&quot;</span>)</div>
<div class="line">    .withShortDescription(<span class="stringliteral">&quot;Add the provided numbers&quot;</span>)</div>
<div class="line">    .withLongDescription(<span class="stringliteral">&quot;Adds all numbers given with the &lt;summand&gt; parameter and prints &quot;</span></div>
<div class="line">                         <span class="stringliteral">&quot;the result to the console.&quot;</span>)</div>
<div class="line">    .withPositionalArgument(cli::commands::createPositionalArgument&lt;double&gt;(<span class="stringliteral">&quot;summand&quot;</span>)</div>
<div class="line">                                .withOptionsComment(<span class="stringliteral">&quot;All the numbers to add&quot;</span>)</div>
<div class="line">                                .withRequired(<span class="keyword">true</span>)</div>
<div class="line">                                .withRepeatable(<span class="keyword">true</span>))</div>
<div class="line">    .withExecutionFunc(add));</div>
<div class="line">cliApp.withCommand(std::move(addCommand));</div>
<div class="ttc" id="aclasscli_1_1commands_1_1_command_html"><div class="ttname"><a href="classcli_1_1commands_1_1_command.html">cli::commands::Command</a></div><div class="ttdoc">Represents a command in the CLI application.</div><div class="ttdef"><b>Definition</b> command.h:36</div></div>
</div><!-- fragment --><p>The command defined above can then be run via <code>&lt;executable_name&gt; add</code> and produces the help documentation: </p><div class="fragment"><div class="line">calculator_demo add &lt;summand&gt;...</div>
<div class="line"> </div>
<div class="line">Adds all numbers given with the &lt;summand&gt; parameter and prints the result to the console.</div>
<div class="line"> </div>
<div class="line">Options:</div>
<div class="line">&lt;summand&gt;...           All the numbers to add</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md6"></a>
4) Use the generated CliContext with the parsed arguments in your own logic</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> add(<span class="keyword">const</span> <a class="code hl_class" href="classcli_1_1_cli_context.html">cli::CliContext</a> &amp;ctx)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> res = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;val : ctx.getRepeatableArg&lt;double&gt;(<span class="stringliteral">&quot;summand&quot;</span>))</div>
<div class="line">    {</div>
<div class="line">        res += val;</div>
<div class="line">    }</div>
<div class="line">    ctx.Logger().<a class="code hl_function" href="classcli_1_1logging_1_1_abstract_logger.html#a4722c6894e9787ae77e114d3e72d3ec6">info</a>(<span class="stringliteral">&quot;Result: {}&quot;</span>, res);</div>
<div class="line">}</div>
<div class="ttc" id="aclasscli_1_1_cli_context_html"><div class="ttname"><a href="classcli_1_1_cli_context.html">cli::CliContext</a></div><div class="ttdoc">Represents the context of a command-line interface (CLI) invocation and as such contains the parsed v...</div><div class="ttdef"><b>Definition</b> cli_context.h:39</div></div>
<div class="ttc" id="aclasscli_1_1logging_1_1_abstract_logger_html_a4722c6894e9787ae77e114d3e72d3ec6"><div class="ttname"><a href="classcli_1_1logging_1_1_abstract_logger.html#a4722c6894e9787ae77e114d3e72d3ec6">cli::logging::AbstractLogger::info</a></div><div class="ttdeci">void info(const std::string &amp;fmt, Args &amp;&amp;...args)</div><div class="ttdoc">Log a message at the INFO level.</div><div class="ttdef"><b>Definition</b> logger.h:110</div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md7"></a>
5) Call the run method of your CliApp with the passed command line arguments</h4>
<p>Either using the predefined macro </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    RUN_CLI_APP(cliApp, argc, argv);</div>
<div class="line">}</div>
</div><!-- fragment --><p> which expands to </p><div class="fragment"><div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> cliInstance.run(argc_, argv_);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> ()</div>
<div class="line">{</div>
<div class="line">    cliInstance.Logger().error() &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    std::abort();</div>
<div class="line">}</div>
</div><!-- fragment --><p>or with your own way of calling CliApp::run.</p>
<blockquote class="doxtable">
<p>&zwj;To see library internal logs define <code>CHAIN_CLI_VERBOSE</code> when compiling. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md8"></a>
Commands</h2>
<p>Commands are created with a unique identifier (=the name of the command to invoke it from the command line) and each command can have its own subcommands that can be added with the <code>withSubcommand</code> method. That means overall the commands are structured in a tree that can be traversed via the identifiers.</p>
<p>Below is an example of what the structure of a CliApp could look like</p>
<div class="fragment"><div class="line">myapp</div>
<div class="line">├── math</div>
<div class="line">│   ├── add &lt;numbers&gt;...</div>
<div class="line">│   ├── subtract &lt;a&gt; &lt;b&gt;</div>
<div class="line">│   └── calc</div>
<div class="line">│       ├── sqrt &lt;number&gt;</div>
<div class="line">│       └── pow &lt;base&gt; &lt;exponent&gt;</div>
<div class="line">└── file</div>
<div class="line">    ├── read &lt;filename&gt;</div>
<div class="line">    ├── write &lt;filename&gt; &lt;content&gt;</div>
<div class="line">    └── compress</div>
<div class="line">       ├── zip &lt;files&gt;...</div>
<div class="line">       └── gzip &lt;file&gt;</div>
</div><!-- fragment --><p>This structure would allow commands like:</p><ul>
<li><code>myapp math add 1,2,3,4</code></li>
<li><code>myapp math calc sqrt 16</code></li>
<li><code>myapp file compress zip file1.txt,file2.txt</code></li>
</ul>
<p>Each command in the tree can have its own arguments, options, and execution logic, while sharing the common CLI infrastructure provided by the library. The root command (fittingly called myapp here, basically corresponds to the executable itself) can be configured through </p><div class="fragment"><div class="line">CliApp::getMainCommand(); <span class="comment">//returns a pointer to the root command</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
Arguments</h2>
<p>Each command can have different arguments added to it that can be configured in itself. There are three types of arguments provided that can be added to a command with the corresponding methods</p>
<p><b>PositionalArguments</b> - <code>Command::withPositionalArgument</code></p>
<p>Arguments that are parsed based on the order they were passed to the application and require at least a name (-&gt; constructor argument)</p>
<div class="fragment"><div class="line">command.withPositionalArgument(cli::commands::createPositionalArgument&lt;double&gt;(<span class="stringliteral">&quot;add&quot;</span>)</div>
<div class="line">                                .withOptionsComment(<span class="stringliteral">&quot;All the numbers to add&quot;</span>)</div>
<div class="line">                                .withRequired(<span class="keyword">true</span>)</div>
<div class="line">                                .withRepeatable(<span class="keyword">true</span>))</div>
</div><!-- fragment --><p> Displayed in the help messages like <code>&lt;positional_name&gt;</code></p>
<p><b>OptionArguments</b> - <code>Command::withOptionArgument</code></p>
<p>Arguments that are parsed based on a preceding flag (usually a long one like <code>--type</code> and a short one like <code>-t</code>) and require at least a (long) name and a value name (-&gt; the constructor arguments)</p>
<div class="fragment"><div class="line">command.withOptionArgument(<a class="code hl_class" href="classcli_1_1commands_1_1_option_argument.html">cli::commands::OptionArgument&lt;double&gt;</a>(<span class="stringliteral">&quot;--bound&quot;</span>, <span class="stringliteral">&quot;lowest&quot;</span>)</div>
<div class="line">                            .withShortName(<span class="stringliteral">&quot;-b&quot;</span>)</div>
<div class="line">                            .withOptionsComment(<span class="stringliteral">&quot;specify a lower bound to display a message if the subtraction process crosses it&quot;</span>))</div>
<div class="ttc" id="aclasscli_1_1commands_1_1_option_argument_html"><div class="ttname"><a href="classcli_1_1commands_1_1_option_argument.html">cli::commands::OptionArgument</a></div><div class="ttdoc">Represents option arguments in the CLI.</div><div class="ttdef"><b>Definition</b> option_argument.h:64</div></div>
</div><!-- fragment --><p> Displayed in the help messages like <code>[--option_name,-short_option_name &lt;value_name&gt;]</code></p>
<p><b>FlagArguments</b> - <code>Command::withFlagArgument</code></p>
<p>Arguments that only check if the specified flag is present or not (can be used like a toggle) and require at least a (long) name and a short name (-&gt; constructor arguments)</p>
<div class="fragment"><div class="line">.withFlagArgument(<a class="code hl_class" href="classcli_1_1commands_1_1_flag_argument.html">cli::commands::FlagArgument</a>(<span class="stringliteral">&quot;--verbose&quot;</span>, <span class="stringliteral">&quot;-v&quot;</span>)</div>
<div class="line">                    .withOptionsComment(<span class="stringliteral">&quot;Enable verbose output for the division process&quot;</span>)</div>
<div class="line">                    .withRequired(<span class="keyword">false</span>))</div>
<div class="ttc" id="aclasscli_1_1commands_1_1_flag_argument_html"><div class="ttname"><a href="classcli_1_1commands_1_1_flag_argument.html">cli::commands::FlagArgument</a></div><div class="ttdoc">Represents a flag argument in the CLI.</div><div class="ttdef"><b>Definition</b> flag_argument.h:31</div></div>
</div><!-- fragment --><p>The first two of these also immediately parse corresponding input parts to a value of the type that was provided when creating the argument. All of the arguments can be required, repeatable and can have a options comment that is displayed in the OPTIONS section of the help command for the corresponding command. Repeatable arguments can be provided in a ','-separated list and are then parsed as a vector instead of a single instance.</p>
<blockquote class="doxtable">
<p>&zwj;Instead of using the chaining methods to create the arguments you can also provide the values to the constructor directly like it is done in the following example: </p>
</blockquote>
<div class="fragment"><div class="line">.withPositionalArgument(<a class="code hl_class" href="classcli_1_1commands_1_1_positional_argument.html">cli::commands::PositionalArgument&lt;double&gt;</a>(</div>
<div class="line">    <span class="stringliteral">&quot;dividend&quot;</span>, <span class="stringliteral">&quot;The number that is divided&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>))</div>
<div class="line">.withPositionalArgument(<a class="code hl_class" href="classcli_1_1commands_1_1_positional_argument.html">cli::commands::PositionalArgument&lt;double&gt;</a>(</div>
<div class="line">    <span class="stringliteral">&quot;divisor&quot;</span>, <span class="stringliteral">&quot;The numbers to divide by&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>))</div>
<div class="line">.withFlagArgument(<a class="code hl_class" href="classcli_1_1commands_1_1_flag_argument.html">cli::commands::FlagArgument</a>(</div>
<div class="line">    <span class="stringliteral">&quot;--remainder&quot;</span>, <span class="stringliteral">&quot;-r&quot;</span>, <span class="stringliteral">&quot;Divide using remainders instead of precise&quot;</span>, <span class="keyword">false</span>))</div>
<div class="ttc" id="aclasscli_1_1commands_1_1_positional_argument_html"><div class="ttname"><a href="classcli_1_1commands_1_1_positional_argument.html">cli::commands::PositionalArgument</a></div><div class="ttdoc">Represents positional arguments in the CLI.</div><div class="ttdef"><b>Definition</b> positional_argument.h:57</div></div>
</div><!-- fragment --><p>In my opinion this is a lot less verbose but it depends on your preferences.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Argument Groups</h2>
<p>Arguments can be put into groups, specifically into mutually exclusive or mutually inclusive ones. This can be done by using the corresponding chaining methods <code>Command::withExclusiveGroup</code> or <code>Command::withInclusiveGroup</code> and passing the arguments you want to have in the group. Inclusive groups require all the arguments in the group to be present if one of them is, while exclusive groups allow only one of the arguments to be present.</p>
<div class="fragment"><div class="line">.withExclusiveGroup(<a class="code hl_class" href="classcli_1_1commands_1_1_option_argument.html">cli::commands::OptionArgument&lt;int&gt;</a>(<span class="stringliteral">&quot;--value&quot;</span>, <span class="stringliteral">&quot;number&quot;</span>)</div>
<div class="line">                                .withShortName(<span class="stringliteral">&quot;-v&quot;</span>)</div>
<div class="line">                                .withOptionsComment(<span class="stringliteral">&quot;First argument in exclusive group&quot;</span>)</div>
<div class="line">                                .withRequired(<span class="keyword">false</span>),</div>
<div class="line">                            <a class="code hl_class" href="classcli_1_1commands_1_1_option_argument.html">cli::commands::OptionArgument&lt;std::string&gt;</a>(<span class="stringliteral">&quot;--name&quot;</span>, <span class="stringliteral">&quot;text&quot;</span>)</div>
<div class="line">                                .withShortName(<span class="stringliteral">&quot;-n&quot;</span>)</div>
<div class="line">                                .withOptionsComment(<span class="stringliteral">&quot;Second argument in exclusive group&quot;</span>)</div>
<div class="line">                                .withRequired(<span class="keyword">false</span>))</div>
</div><!-- fragment --><div class="fragment"><div class="line">.withInclusiveGroup(<a class="code hl_class" href="classcli_1_1commands_1_1_option_argument.html">cli::commands::OptionArgument&lt;int&gt;</a>(<span class="stringliteral">&quot;--value&quot;</span>, <span class="stringliteral">&quot;number&quot;</span>)</div>
<div class="line">                                .withShortName(<span class="stringliteral">&quot;-v&quot;</span>)</div>
<div class="line">                                .withOptionsComment(<span class="stringliteral">&quot;First argument in inclusive group&quot;</span>)</div>
<div class="line">                                .withRequired(<span class="keyword">false</span>),</div>
<div class="line">                            <a class="code hl_class" href="classcli_1_1commands_1_1_option_argument.html">cli::commands::OptionArgument&lt;std::string&gt;</a>(<span class="stringliteral">&quot;--name&quot;</span>, <span class="stringliteral">&quot;text&quot;</span>)</div>
<div class="line">                                .withShortName(<span class="stringliteral">&quot;-n&quot;</span>)</div>
<div class="line">                                .withOptionsComment(<span class="stringliteral">&quot;Second argument in inclusive group&quot;</span>)</div>
<div class="line">                                .withRequired(<span class="keyword">false</span>))</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;Using this, one can quite easily create uncallable commands, for example creating a mutually exclusive group where two of the arguments in it are required. The library doesn't check for this and so will not provide any warnings or something similar. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md11"></a>
Cli Context</h2>
<p>To pass the parsed Arguments to the implemented logic the library uses <code>CliContext</code> instances. These provide access to them using the corresponding methods like <code>CliContext::getPositionArg</code> or <code>CliContext::getArg</code> (internally this one searches through flag, positional and option args). Note that you have to provide the argument name that was specified when creating the argument to retrieve its value. As arguments that are not required don't have to be present, there are methods to check if they were provided, namely <code>CliContext::isOptionArgPresent</code> and equivalents for the other argument types.</p>
<div class="fragment"><div class="line"><span class="comment">// Example: Accessing different argument types in your command function</span></div>
<div class="line"><span class="keywordtype">void</span> subtract(<span class="keyword">const</span> <a class="code hl_class" href="classcli_1_1_cli_context.html">cli::CliContext</a> &amp;ctx)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> minuend = ctx.<a class="code hl_function" href="classcli_1_1_cli_context.html#a91e4bb8e5c75cb8dd9963daf3065098f">getPositionalArg</a>&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;minuend&quot;</span>);</div>
<div class="line">    <span class="keywordtype">double</span> bound = minuend + 1; <span class="comment">// just to have an initial value</span></div>
<div class="line">    <span class="keywordtype">bool</span> boundPresent = ctx.<a class="code hl_function" href="classcli_1_1_cli_context.html#a7f23be3d2006d0859a94f14cdd03b043">isOptionArgPresent</a>(<span class="stringliteral">&quot;--bound&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;val : ctx.getRepeatableArg&lt;double&gt;(<span class="stringliteral">&quot;subtrahend&quot;</span>))</div>
<div class="line">    {</div>
<div class="line">        minuend -= val;</div>
<div class="line">        <span class="keywordflow">if</span> (boundPresent &amp;&amp; minuend &lt; bound)</div>
<div class="line">        {</div>
<div class="line">            ctx.Logger().<a class="code hl_function" href="classcli_1_1logging_1_1_abstract_logger.html#a4722c6894e9787ae77e114d3e72d3ec6">info</a>(<span class="stringliteral">&quot;Subtraction crossed the bound of {}: current value is {}&quot;</span>, bound,</div>
<div class="line">                            minuend);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    ctx.Logger().<a class="code hl_function" href="classcli_1_1logging_1_1_abstract_logger.html#a4722c6894e9787ae77e114d3e72d3ec6">info</a>(<span class="stringliteral">&quot;Result: {}&quot;</span>, minuend);</div>
<div class="line">}</div>
<div class="ttc" id="aclasscli_1_1_cli_context_html_a7f23be3d2006d0859a94f14cdd03b043"><div class="ttname"><a href="classcli_1_1_cli_context.html#a7f23be3d2006d0859a94f14cdd03b043">cli::CliContext::isOptionArgPresent</a></div><div class="ttdeci">bool isOptionArgPresent(const std::string &amp;argName) const</div><div class="ttdoc">Checks if an optional argument with the given name is present in the context.</div><div class="ttdef"><b>Definition</b> cli_context.cpp:24</div></div>
<div class="ttc" id="aclasscli_1_1_cli_context_html_a91e4bb8e5c75cb8dd9963daf3065098f"><div class="ttname"><a href="classcli_1_1_cli_context.html#a91e4bb8e5c75cb8dd9963daf3065098f">cli::CliContext::getPositionalArg</a></div><div class="ttdeci">T getPositionalArg(const std::string &amp;argName) const</div><div class="ttdoc">Gets the value of a positional argument.</div><div class="ttdef"><b>Definition</b> cli_context.h:84</div></div>
</div><!-- fragment --><p>Additionally the <code>CliContext</code> objects carry a reference to the CliApps Logger instance which can be accessed through <code>CliContext::Logger</code> so you can use the configured Logger in your own logic.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Command Docstrings</h2>
<p>Internally the text that is printed for help messages is called a docstring and commands have both a short and a long docstring. The first one is used in help message for the whole app (printed when the executable is invoked without a valid command to call or with &lt;executable&gt; &ndash;help) and the second one in the help message for each single command (printed via &lt;executable&gt; &lt;command_name&gt; &ndash;help).</p>
<p><b>example of an app help message</b> </p><div class="fragment"><div class="line">Calculator Demo to test the CLI Library</div>
<div class="line"> </div>
<div class="line">calculator_demo add &lt;summand&gt;... </div>
<div class="line">Add the provided numbers</div>
<div class="line"> </div>
<div class="line">calculator_demo div &lt;dividend&gt; &lt;divisor&gt;... [--remainder,-r] </div>
<div class="line">Divide the first argument by all args after it</div>
<div class="line"> </div>
<div class="line">calculator_demo mult &lt;factor&gt;... </div>
<div class="line">Multiply the provided numbers</div>
<div class="line"> </div>
<div class="line">calculator_demo sub &lt;minuend&gt; &lt;subtrahend&gt;... [--bound,-b &lt;lowest&gt;] </div>
<div class="line">Subtracts all the numbers after the first one from it</div>
<div class="line"> </div>
<div class="line">Use &lt;command&gt; --help|-h to get more information about a specific command</div>
</div><!-- fragment --><p><b>example of a command help message</b> </p><div class="fragment"><div class="line">calculator_demo sub &lt;minuend&gt; &lt;subtrahend&gt;... [--bound,-b &lt;lowest&gt;] </div>
<div class="line"> </div>
<div class="line">Subtracts all numbers given with the &lt;subtrahend&gt; parameter from the number given with the &lt;minuend&gt; parameter and prints the result to the console.</div>
<div class="line"> </div>
<div class="line">Options:</div>
<div class="line">&lt;minuend&gt;              The number that is subtracted from</div>
<div class="line">&lt;subtrahend&gt;...        All the numbers to subtract</div>
<div class="line">--bound,-b &lt;lowest&gt;    specify a lower bound to display a message if the subtraction process crosses it</div>
</div><!-- fragment --><p>The text in the middle is the short or long description of the command (can be specified for each command with the chaining methods). The display in the first line and the textual representation of the arguments is modeled after <a href="http://docopt.org/">docopt</a> meaning:</p>
<ul>
<li>required positional arguments are enclosed in <code>&lt;&gt;</code> and optional positional arguments in <code>[]</code>. They display their name in the brackets: <code>&lt;minuend&gt;</code></li>
<li>required option arguments are enclosed in <code>()</code> and optional positional arguments in <code>[]</code>. They display their name followed by a semicolon and the short name (if one was specified) as well as the value_name enclosed in <code>&lt;&gt;</code>: <code>[--bound,-b &lt;lowest&gt;]</code></li>
<li>flag arguments are always optional and enclosed in <code>[]</code>. They display their name and short name (if specified) in the same fashion that option arguments do: <code>[--remainder,-r]</code></li>
<li>repeatable arguments are differentiated by adding <code>...</code> after the argument itself : <code>&lt;summand&gt;...</code></li>
<li>like option arguments, argument groups are enclosed by <code>()</code> if required and <code>[]</code> otherwise. Additionally exclusive groups separate their arguments by <code>|</code> whereas inclusive groups simply use spaces. Inclusive groups are required as soon as one of their arguments is required and exclusive groups if every one of their arguments is required : <code>[[--value,-v &lt;number&gt;] | [--name,-n &lt;text&gt;]]</code></li>
</ul>
<blockquote class="doxtable">
<p>&zwj;The order of the arguments in the display is determined by the order the arguments were added to the command! </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md13"></a>
CliApp Configuration</h2>
<p>The <code>CliConfig</code> struct is used to configure the CliApplication and change default presets. You can either pass your own instance when creating the CliApp or later edit the configuration via <code>CliApp::getConfig</code>. Examples of settings that can be changed this way are the optionsWidth the help messages use for the line length in the Options section and the alignment there or the repeatableDelimiter used to split repeatable arguments (default ","), as well as the executable name or similar project specific details.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Logging</h2>
<p>The library uses a simple logging module that works by creating a single logger instance and attaching handlers with their own formatters to it. Each Handler is responsible for outputting a message that was formatted by its formatter (the default formatters provided are the message only formatter and one that includes timestamp and loglevel) to a different target (the default handlers provided target either the console or a file).</p>
<p>Both the logger itself and all the handlers have a minimum level and ignore all logs that are below it. The one of the logger can be set with <code>Logger::setLevel</code> for the handlers they have to be specified before adding them to the logger, e.g in the constructor (the default console handler has Trace as its level).</p>
<p>Moreover a simple LogStyle struct (basically a map of LogLevel to strings) is used to style each loglevel with ANSI-escape-sequences. By default this is only used to color the output for the different levels, like so</p>
<p><span style="color: gray">This is a TRACE message</span> <br  />
 <span style="color: gray">This is a VERBOSE message</span> <br  />
 <span style="color: blue">This is a DEBUG message</span> <br  />
 This is an INFO message <br  />
 <span style="color: orange">This is a WARNING message</span> <br  />
 <span style="color: green">This is a SUCCESS message</span> <br  />
 <span style="color: red">This is an ERROR message</span></p>
<p>You can easily write your own handler or formatter by extending the corresponding abstract base class (<code>AbstractHandler</code> or <code>AbstractFormatter</code>). If needed one can also write their own implementation of the <code>AbstractLogger</code> and pass it when creating the CliApp to use instead of the one the library provides.</p>
<blockquote class="doxtable">
<p>&zwj;The streams available with <code>Logger::info</code>, <code>Logger::debug</code> and so on have to be manually flushed using <code>std::flush</code>! </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md15"></a>
Docformatters</h2>
<p>To generate its help messages the library uses one central class the <code>Docwriter</code> which has references to different types of docformatters: One for each argument type (positional/option/flag), one for a single command and one for the application as a whole.</p>
<p>At the start of the program both the short and long docstring for each command is built by first retrieving the docstrings (called ArgumentDocString for the display with the brackets in the first line and OptionsDocString for the line in the OPTIONS section) for the arguments which results in calls to the docwriter and their regarding formatters. These are then used by a the commandFormatter to build and set the long/short docstring per command.</p>
<p>If a help message then needs to be printed (either the one for the app or for a single command) the already built docstrings of the commands are used by the AppFormatter to produce the final output.</p>
<p>All of these steps can be fully customized by replacing the default formatters with your own implementation of the abstract base classes (<code>AbstractCliAppDocFormatter</code>, <code>AbstractCommandFormatter</code> and <code>AbstractArgDocFormatter</code>) like below:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CustomOptionFormatter : <span class="keyword">public</span> <a class="code hl_class" href="classcli_1_1commands_1_1docwriting_1_1_default_option_formatter.html">cli::commands::docwriting::DefaultOptionFormatter</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string <a class="code hl_function" href="classcli_1_1commands_1_1docwriting_1_1_default_option_formatter.html#ae65237966c8d084821dd91aa497f42f2">generateArgDocString</a>(<span class="keyword">const</span> <a class="code hl_class" href="classcli_1_1commands_1_1_option_argument_base.html">cli::commands::OptionArgumentBase</a> &amp;argument,</div>
<div class="line">                                     <span class="keyword">const</span> <a class="code hl_struct" href="structcli_1_1_cli_config.html">cli::CliConfig</a> &amp;configuration)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        std::ostringstream builder;</div>
<div class="line">        builder &lt;&lt; <span class="stringliteral">&quot;[Option: &quot;</span> &lt;&lt; argument.<a class="code hl_function" href="classcli_1_1commands_1_1_argument_base.html#aef138d4789e04fe2f331530f1102ed00">getName</a>();</div>
<div class="line">        <span class="keywordflow">if</span> (argument.<a class="code hl_function" href="classcli_1_1commands_1_1_argument_base.html#a207a84d6c076fbc116687c611dff4b3d">isRequired</a>())</div>
<div class="line">            builder &lt;&lt; <span class="stringliteral">&quot;, Required&quot;</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (argument.<a class="code hl_function" href="classcli_1_1commands_1_1_argument_base.html#ab476bef223598cfa040dd8643768bab2">isRepeatable</a>())</div>
<div class="line">            builder &lt;&lt; <span class="stringliteral">&quot;, Repeatable&quot;</span>;</div>
<div class="line">        builder &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> builder.str();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string <a class="code hl_function" href="classcli_1_1commands_1_1docwriting_1_1_default_option_formatter.html#a94b6e08df40623e5def4065996982e49">generateOptionsDocString</a>(<span class="keyword">const</span> <a class="code hl_class" href="classcli_1_1commands_1_1_option_argument_base.html">cli::commands::OptionArgumentBase</a> &amp;argument,</div>
<div class="line">                                         <span class="keyword">const</span> <a class="code hl_struct" href="structcli_1_1_cli_config.html">cli::CliConfig</a> &amp;configuration)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        std::ostringstream builder;</div>
<div class="line">        builder &lt;&lt; <a class="code hl_function" href="classcli_1_1commands_1_1docwriting_1_1_default_option_formatter.html#a94b6e08df40623e5def4065996982e49">DefaultOptionFormatter::generateOptionsDocString</a>(argument, configuration);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (argument.<a class="code hl_function" href="classcli_1_1commands_1_1_argument_base.html#a207a84d6c076fbc116687c611dff4b3d">isRequired</a>())</div>
<div class="line">            builder &lt;&lt; <span class="stringliteral">&quot; (Required)&quot;</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (argument.<a class="code hl_function" href="classcli_1_1commands_1_1_argument_base.html#ab476bef223598cfa040dd8643768bab2">isRepeatable</a>())</div>
<div class="line">            builder &lt;&lt; <span class="stringliteral">&quot; (Repeatable)&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> builder.str();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> cliApp = <a class="code hl_class" href="classcli_1_1_cli_app.html">cli::CliApp</a>(<span class="stringliteral">&quot;DocFormatterDemo&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    initCommands(cliApp);</div>
<div class="line"> </div>
<div class="line">    cliApp.getDocWriter().setAppFormatter(std::make_unique&lt;CustomAppDocFormatter&gt;());</div>
<div class="line">    cliApp.getDocWriter().setOptionFormatter(std::make_unique&lt;CustomOptionFormatter&gt;());</div>
<div class="line">}</div>
<div class="ttc" id="aclasscli_1_1commands_1_1_argument_base_html_a207a84d6c076fbc116687c611dff4b3d"><div class="ttname"><a href="classcli_1_1commands_1_1_argument_base.html#a207a84d6c076fbc116687c611dff4b3d">cli::commands::ArgumentBase::isRequired</a></div><div class="ttdeci">constexpr bool isRequired() const noexcept</div><div class="ttdoc">Check if the argument is required.</div><div class="ttdef"><b>Definition</b> argument.h:63</div></div>
<div class="ttc" id="aclasscli_1_1commands_1_1_argument_base_html_ab476bef223598cfa040dd8643768bab2"><div class="ttname"><a href="classcli_1_1commands_1_1_argument_base.html#ab476bef223598cfa040dd8643768bab2">cli::commands::ArgumentBase::isRepeatable</a></div><div class="ttdeci">constexpr bool isRepeatable() const noexcept</div><div class="ttdoc">Check if the argument is repeatable.</div><div class="ttdef"><b>Definition</b> argument.h:67</div></div>
<div class="ttc" id="aclasscli_1_1commands_1_1_argument_base_html_aef138d4789e04fe2f331530f1102ed00"><div class="ttname"><a href="classcli_1_1commands_1_1_argument_base.html#aef138d4789e04fe2f331530f1102ed00">cli::commands::ArgumentBase::getName</a></div><div class="ttdeci">constexpr std::string_view getName() const noexcept</div><div class="ttdoc">Get the name of the argument.</div><div class="ttdef"><b>Definition</b> argument.h:50</div></div>
<div class="ttc" id="aclasscli_1_1commands_1_1_option_argument_base_html"><div class="ttname"><a href="classcli_1_1commands_1_1_option_argument_base.html">cli::commands::OptionArgumentBase</a></div><div class="ttdoc">Untemplated base class for option arguments in the CLI. Used to store all option arguments in a singl...</div><div class="ttdef"><b>Definition</b> option_argument.h:33</div></div>
<div class="ttc" id="aclasscli_1_1commands_1_1docwriting_1_1_default_option_formatter_html"><div class="ttname"><a href="classcli_1_1commands_1_1docwriting_1_1_default_option_formatter.html">cli::commands::docwriting::DefaultOptionFormatter</a></div><div class="ttdoc">Default formatter for option arguments.</div><div class="ttdef"><b>Definition</b> docformatter.h:67</div></div>
<div class="ttc" id="aclasscli_1_1commands_1_1docwriting_1_1_default_option_formatter_html_a94b6e08df40623e5def4065996982e49"><div class="ttname"><a href="classcli_1_1commands_1_1docwriting_1_1_default_option_formatter.html#a94b6e08df40623e5def4065996982e49">cli::commands::docwriting::DefaultOptionFormatter::generateOptionsDocString</a></div><div class="ttdeci">std::string generateOptionsDocString(const OptionArgumentBase &amp;argument, const cli::CliConfig &amp;configuration) override</div><div class="ttdoc">Generate the options documentation string.</div><div class="ttdef"><b>Definition</b> docformatter.cpp:79</div></div>
<div class="ttc" id="aclasscli_1_1commands_1_1docwriting_1_1_default_option_formatter_html_ae65237966c8d084821dd91aa497f42f2"><div class="ttname"><a href="classcli_1_1commands_1_1docwriting_1_1_default_option_formatter.html#ae65237966c8d084821dd91aa497f42f2">cli::commands::docwriting::DefaultOptionFormatter::generateArgDocString</a></div><div class="ttdeci">std::string generateArgDocString(const OptionArgumentBase &amp;argument, const cli::CliConfig &amp;configuration) override</div><div class="ttdoc">Generate the argument documentation string.</div><div class="ttdef"><b>Definition</b> docformatter.cpp:63</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
Custom Types</h2>
<p>To parse the input string to actual values the library simply uses the <code>&gt;&gt;</code> operator, therefore you simply have to provide an appropriate overload of that operator for the parsing module to use.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>CustomType</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">friend</span> std::istream &amp;operator&gt;&gt;(std::istream &amp;is, CustomType &amp;ct)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Custom parse implementation</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Thats it! If some things are not fully clear yet, try having a look at the <a href="https://github.com/Dr0f0x/ChainCLI/tree/v1.0.0-alpha/demo">demo projects</a> or dive deeper into the detailed API-Reference. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
